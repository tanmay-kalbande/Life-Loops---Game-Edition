<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebApplication">

<head>
    <!-- Primary Meta Tags -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Life Loops - Habit Tracking RPG</title>
    <meta name="description" content="Life Loops - Gamified Habit Tracker. Build positive habits and break negative ones through an 8-bit RPG-inspired interface. Track your daily streaks and earn achievements!">
    <meta name="keywords" content="habit tracker, productivity game, RPG habits, life improvement, daily streaks, gamification, personal development, mobile habit tracker">
    <meta name="author" content="Tanmay Kalbande">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="./assets/triangles.png"> <!-- Make sure this path is correct -->

    <!-- NES.css and Font -->
    <link href="https://unpkg.com/nes.css@latest/css/nes.min.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <!-- Confetti -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>

    <!-- Vercel Analytics (Optional) -->
    <script>
        window.va = window.va || function() {
            (window.vaq = window.vaq || []).push(arguments);
        };
    </script>
    <script defer src="/_vercel/insights/script.js"></script>

    <!-- Schema.org Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Life Loops",
        "description": "Gamified habit tracking application with retro RPG aesthetics for mobile",
        "applicationCategory": "Productivity",
        "operatingSystem": "Web",
        "author": {
            "@type": "Organization",
            "name": "Life Loops Dev Team"
        },
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        }
    }
    </script>

    <style>
        /* Reset and Base */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 10px;
            /* Base font size for rem units */
        }

        body {
            background: #202020 url('data:image/svg+xml,%3Csvg width="6" height="6" viewBox="0 0 6 6" xmlns="http://www.w3.org/2000/svg"%3E%3Cg fill="%23404040" fill-opacity="0.4" fill-rule="evenodd"%3E%3Cpath d="M5 0h1L0 6V5zM6 5v1H5z"/%3E%3C/g%3E%3C/svg%3E');
            /* Subtle dark pattern */
            padding: 1.5rem 1rem;
            font-family: 'Press Start 2P', cursive;
            line-height: 1.6;
            min-height: 100vh;
            color: #fff;
        }

        /* Container */
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            /* Increased gap */
        }

        /* Header */
        .game-header {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            text-align: center;
            margin-bottom: 1rem;
        }

        .title-container {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .main-title {
            font-size: 2rem;
            color: #e74c3c;
            /* NES red */
            text-shadow: 3px 3px 0 #000;
            animation: titleGlow 1.5s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from {
                text-shadow: 3px 3px 0 #000, 0 0 5px #ff9900;
            }
            to {
                text-shadow: 3px 3px 0 #000, 0 0 15px #ffcc00, 0 0 20px #ffcc00;
            }
        }

        .title-icon {
            font-size: 2.5rem;
            animation: float 2s ease-in-out infinite;
        }

        @keyframes float {
            0%,
            100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-6px);
            }
        }

        /* Points Counter */
        .points-counter {
            padding: 1rem 1.5rem;
            background: #fff;
            border: 4px solid #000;
            border-radius: 0;
            /* NES style */
            box-shadow: 4px 4px 0 #000;
            font-size: 1.2rem;
            display: inline-flex;
            align-items: center;
            gap: 1rem;
            color: #212529;
            flex-wrap: wrap;
            /* Allow wrapping */
            justify-content: center;
            /* Center items when wrapped */
        }

        .points-counter span {
            font-weight: bold;
            color: #e74c3c;
            /* NES red for numbers */
            min-width: 1.5em;
            /* Ensure space for numbers */
            text-align: center;
        }

        .points-counter i.nes-icon.star,
        .points-counter i.nes-icon.trophy {
            margin-right: 0.5rem;
        }

        /* Add Loop Section */
        .add-loop-section {
            background-color: #fff;
            color: #212529;
            padding: 1.5rem;
            box-shadow: 4px 4px 0 #000;
            border: 4px solid #000;
        }

        .nes-field {
            margin-bottom: 1rem;
        }

        .nes-field:last-of-type {
            margin-bottom: 1.5rem;
            /* More space before button */
        }

        .nes-input,
        .nes-select select {
            /* Target select element inside nes-select */
            font-size: 1.2rem;
            /* Slightly larger input text */
            padding: 1rem;
            width: 100%;
            /* Ensure full width */
        }

        /* Ensure nes-select div takes full width */
        .nes-select {
            width: 100%;
        }

        .nes-btn {
            font-size: 1.2rem;
            padding: 1rem;
            transition: transform 0.1s ease;
        }

        .nes-btn:active {
            transform: translateY(2px);
            /* NES button press effect */
        }

        /* Loops Container (Card Layout) */
        #loops-container {
            display: grid;
            grid-template-columns: 1fr;
            /* Single column by default */
            gap: 1.8rem;
            min-height: 50px;
            /* Give it some height even when empty */
        }

        /* Style for the 'no loops' message */
        #no-loops-message {
            color: #777;
            /* Lighter grey */
            text-align: center;
            font-size: 1.1rem;
            padding: 2rem 1rem;
            border: 2px dashed #555;
            /* Dashed border */
            display: none;
            /* Hidden by default, shown via JS */
            width: 100%;
            /* Take full width of the grid area */
        }

        /* Loop Card */
        .loop-card {
            background-color: #fff;
            color: #212529;
            border: 4px solid #000;
            padding: 1.2rem;
            box-shadow: 4px 4px 0 #000;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .loop-card.is-positive {
            border-left: 8px solid #92cc41;
            /* NES green */
        }

        .loop-card.is-negative {
            border-left: 8px solid #e76e55;
            /* NES orange/red */
        }

        .loop-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            /* Align items top */
            gap: 1rem;
            padding-bottom: 0.8rem;
            border-bottom: 2px dashed #ccc;
            /* Separator */
        }

        .loop-card-title {
            font-size: 1.4rem;
            word-break: break-word;
            /* Prevent overflow */
            flex-grow: 1;
            /* Allow title to take available space */
            margin-right: 1rem;
            /* Space before icon */
            line-height: 1.4;
            /* Adjust line height for wrapping */
        }

        .loop-card-type {
            font-size: 2rem;
            flex-shrink: 0;
            /* Prevent icon from shrinking */
        }

        .loop-card-body {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            font-size: 1.1rem;
        }

        .loop-streak {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .loop-history {
            line-height: 1.8;
            /* More space for badges */
        }

        .loop-history .nes-badge {
            font-size: 0.9rem;
            padding: 3px 5px;
            margin-right: 4px;
            margin-bottom: 4px;
            /* Space if badges wrap */
            display: inline-block;
            /* Ensure margin/padding works */
        }

        .loop-card-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            /* Increased space above actions */
        }

        .loop-card-actions .nes-btn {
            flex: 1;
            /* Make buttons share space */
            padding: 0.8rem;
            font-size: 1.1rem;
        }

        .loop-card-actions .nes-btn.is-success {
            font-size: 1.5rem;
            line-height: 1;
        }

        /* Larger Checkmark */
        .loop-card-actions .nes-btn.is-error {
            font-size: 1.3rem;
            line-height: 1;
        }

        /* Larger Bin */

        /* Stats Section */
        .stats-section {
            background-color: #fff;
            color: #212529;
            padding: 1.5rem;
            box-shadow: 4px 4px 0 #000;
            border: 4px solid #000;
        }

        .stats-list dt {
            font-weight: normal;
            margin-bottom: 0.8rem;
            /* More space between stats */
            font-size: 1.2rem;
            display: inline-block;
            min-width: 15ch;
            /* Align values */
            color: #555;
            /* Dim the label slightly */
        }

        .stats-list dd {
            display: inline-block;
            font-weight: bold;
            font-size: 1.2rem;
            margin-left: 1rem;
            color: #e74c3c;
        }

        /* Import/Export */
        .file-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            /* Center buttons */
            margin-top: 1rem;
        }

        .file-actions .nes-btn {
            padding: 0.8rem 1.2rem;
            font-size: 1rem;
            min-width: 120px;
            /* Give buttons some width */
        }

        /* Mobile Alert */
        .mobile-alert {
            display: none;
            /* Hidden by default */
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a1a;
            border: 3px solid #ffd700;
            /* Gold border */
            border-radius: 0;
            /* NES style */
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
            color: #ffd700;
            /* Gold text */
            font-family: 'Press Start 2P', cursive;
            padding: 1.5rem;
            text-align: center;
            z-index: 1000;
            width: 90%;
            max-width: 400px;
            font-size: 1rem;
            animation: alertGlow 1.5s infinite alternate;
        }

        .mobile-alert::before {
            content: '⚠️';
            display: block;
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .mobile-alert .close-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 30px;
            height: 30px;
            padding: 0;
            /* Remove default padding */
            font-size: 1.5rem;
            line-height: 28px;
            /* Center icon vertically */
            border-radius: 50%;
            box-shadow: 2px 2px 0 #000;
        }

        @keyframes alertGlow {
            from {
                box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
            }
            to {
                box-shadow: 0 0 16px rgba(255, 215, 0, 0.6);
            }
        }

        /* Responsive Adjustments */
        @media (min-width: 480px) {
            html {
                font-size: 11px;
                /* Slightly larger base on wider screens */
            }
            body {
                padding: 2rem;
            }
            .points-counter {
                font-size: 1.4rem;
            }
            #loops-container {
                /* Two columns on slightly wider screens */
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            }
            #no-loops-message {
                /* Ensure it spans correctly if grid has columns */
                grid-column: 1 / -1;
            }
            .main-title {
                font-size: 2.4rem;
            }
            .title-icon {
                font-size: 3rem;
            }
        }

        @media (min-width: 768px) {
            html {
                font-size: 12px;
            }
            .container {
                max-width: 800px;
                /* Wider container for desktop */
            }
            .game-header {
                flex-direction: row;
                /* Side-by-side on larger screens */
                justify-content: space-between;
                align-items: center;
            }
            #loops-container {
                /* Potentially 3 columns on desktop if space allows */
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            }
        }
    </style>
</head>

<body>

    <!-- Mobile Orientation Alert -->
    <div class="mobile-alert">
        <span>Rotate device to Landscape for optimal view!</span>
        <button class="close-btn nes-btn is-error" onclick="dismissAlert()">X</button>
    </div>

    <div class="container">
        <!-- Header -->
        <header class="game-header">
            <div class="title-container">
                <span class="title-icon">⚔️</span>
                <h1 class="main-title">LIFE LOOPS</h1>
            </div>
            <div class="points-counter">
                <i class="nes-icon star is-medium"></i> D: <span id="dailyPoints">0</span>/10 | <i class="nes-icon trophy is-medium"></i> T: <span id="totalPoints">0</span>
            </div>
        </header>

        <!-- Add Loop -->
        <section class="nes-container with-title is-dark add-loop-section">
            <p class="title">➕ Create New Loop</p>
            <div class="nes-field">
                <label for="loopInput">Loop Name:</label>
                <input type="text" id="loopInput" class="nes-input is-dark" placeholder="e.g., Morning Run">
            </div>
            <div class="nes-field">
                <label for="loopType">Loop Type:</label>
                <div class="nes-select is-dark">
                    <select required id="loopType">
                        <option value="positive" selected>✅ Positive</option>
                        <option value="negative">❌ Negative</option>
                    </select>
                </div>
            </div>
            <button class="nes-btn is-success" onclick="addLoop()">Add Loop</button>
        </section>

        <!-- Active Loops (Cards) -->
        <section class="nes-container with-title is-dark">
            <p class="title">🔄 Active Loops</p>
            <!-- Container for cards -->
            <div id="loops-container">
                <!-- Loop cards will be dynamically added here by updateUI -->
            </div>
            <!-- Message shown when container is empty -->
            <p id="no-loops-message" style="display: none;">No active loops yet. Add one above!</p>
        </section>

        <!-- Stats -->
        <section class="nes-container with-title is-dark stats-section">
            <p class="title">📊 Game Stats</p>
            <dl class="stats-list">
                <div><dt>🔥 Overall Streak:</dt><dd id="streak">0 days</dd></div>
                <div><dt>✅ Positive Loops:</dt><dd id="positiveCount">0</dd></div>
                <div><dt>❌ Negative Loops:</dt><dd id="negativeCount">0</dd></div>
            </dl>
        </section>

        <!-- Import/Export Buttons -->
        <div class="file-actions">
            <button class="nes-btn is-warning" onclick="document.getElementById('importInput').click()">
                📥 Import
            </button>
            <button class="nes-btn is-primary" onclick="exportCSV()">
                📤 Export
            </button>
            <input type="file" id="importInput" hidden accept=".csv" onchange="importCSV(event)">
        </div>

    </div>

    <script>
        // --- State Management & Core Logic ---

        const getIndianTime = () => {
            const now = new Date();
            const offset = 5.5 * 60 * 60 * 1000; // IST Offset UTC+5:30
            const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
            return new Date(utc + offset);
        };

        const getTodayDateString = () => {
            const date = getIndianTime();
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`; // Format YYYY-MM-DD
        };

        // Load initial state from localStorage or set defaults
        let state = {
            loops: JSON.parse(localStorage.getItem('loops')) || [],
            dailyLog: JSON.parse(localStorage.getItem('dailyLog')) || [],
            totalPoints: parseInt(localStorage.getItem('totalPoints')) || 0,
            streak: parseInt(localStorage.getItem('streak')) || 0,
            lastUpdatedDate: localStorage.getItem('lastUpdatedDate') || null
        };

        // Simple audio cache to avoid reloading sounds
        const audioCache = {};
        function playSound(type) {
            const urls = {
                positive: 'https://assets.mixkit.co/active_storage/sfx/257/257-preview.mp3',
                negative: 'https://assets.mixkit.co/active_storage/sfx/259/259-preview.mp3',
                achievement: 'https://assets.mixkit.co/active_storage/sfx/2958/2958-preview.mp3',
                add: 'https://assets.mixkit.co/active_storage/sfx/103/103-preview.mp3',
                delete: 'https://assets.mixkit.co/active_storage/sfx/168/168-preview.mp3'
            };
            if (!urls[type]) return;

            // Create audio object if not cached
            if (!audioCache[type]) {
                audioCache[type] = new Audio(urls[type]);
                audioCache[type].volume = 0.6; // Adjust volume if needed
            }

            // Play the sound
            audioCache[type].currentTime = 0; // Rewind to start
            audioCache[type].play().catch(e => console.error(`Audio playback failed for type "${type}":`, e));
        }

        // Save the current state to localStorage
        function saveState() {
            try {
                localStorage.setItem('loops', JSON.stringify(state.loops));
                localStorage.setItem('dailyLog', JSON.stringify(state.dailyLog));
                localStorage.setItem('totalPoints', state.totalPoints);
                localStorage.setItem('streak', state.streak);
                // Save lastUpdatedDate as string, empty if null
                localStorage.setItem('lastUpdatedDate', state.lastUpdatedDate || '');
            } catch (error) {
                console.error("Error saving state to localStorage:", error);
                // Optionally notify the user that saving failed
                // alert("Warning: Could not save your progress. Local storage might be full or disabled.");
            }
        }

        // --- UI Update & Rendering ---

        function updateUI() {
            const today = getTodayDateString();
            const container = document.getElementById('loops-container');
            const noLoopsMessage = document.getElementById('no-loops-message');

            // Ensure required elements exist before proceeding
            if (!container || !noLoopsMessage) {
                console.error("Critical error: UI container elements (#loops-container or #no-loops-message) not found.");
                return;
            }

            // --- Update Core State Metrics ---
            // Calculate overall streak BEFORE updating display elements
            updateStreak(today);

            // Find today's log entry for point display
            const todayData = state.dailyLog.find(d => d.date === today) || {
                points: 0
            };

            // --- Update Static Display Elements ---
            document.getElementById('dailyPoints').textContent = todayData.points;
            document.getElementById('totalPoints').textContent = state.totalPoints;
            document.getElementById('streak').textContent = `${state.streak} day${state.streak === 1 ? '' : 's'}`;
            document.getElementById('positiveCount').textContent = state.loops.filter(l => l.type === 'positive').length;
            document.getElementById('negativeCount').textContent = state.loops.filter(l => l.type === 'negative').length;

            // --- Render Loop Cards ---
            if (state.loops.length === 0) {
                container.innerHTML = ''; // Clear if empty
                noLoopsMessage.style.display = 'block'; // Show the 'no loops' message
            } else {
                noLoopsMessage.style.display = 'none'; // Hide the 'no loops' message

                // Create a sorted copy for rendering (e.g., by creation date)
                const sortedLoops = [...state.loops].sort((a, b) => (a.created || '').localeCompare(b.created || ''));

                // Generate HTML for all cards using map and join
                const cardsHTML = sortedLoops.map(loop => {
                    // Calculate individual loop streak for display
                    const loopStreak = calculateLoopStreak(loop.completions, today);
                    const isCompletedToday = loop.completions.includes(today);

                    // Generate history badges (limit to last 5, newest first)
                    const historyDates = loop.completions
                        .slice(-5) // Get the last 5 completion dates
                        .sort((a, b) => b.localeCompare(a)) // Sort them descending (newest first)
                        .map(d => {
                            // Format date string for display (e.g., '25 Dec')
                            const [year, month, day] = d.split('-');
                            const dateObj = new Date(Date.UTC(year, month - 1, day)); // Use UTC for consistency
                            const displayDate = dateObj.toLocaleDateString('en-IN', {
                                day: 'numeric',
                                month: 'short',
                                timeZone: 'UTC'
                            });
                            // Style badge differently if it's today's date
                            const badgeClass = d === today ? 'is-primary' : 'is-dark';
                            return `<span class="nes-badge ${badgeClass}"><span class="${badgeClass}">${displayDate}</span></span>`;
                        })
                        .join(' '); // Join badge HTML strings

                    // Return the complete HTML string for one card
                    return `
                    <div class="nes-container is-rounded loop-card is-${loop.type}" data-loop-id="${loop.id}">
                        <div class="loop-card-header">
                            <span class="loop-card-title">${loop.name}</span>
                            <span class="loop-card-type">${loop.type === 'positive' ? '✅' : '❌'}</span>
                        </div>
                        <div class="loop-card-body">
                            <div class="loop-streak">
                                🔥 Streak: <strong>${loopStreak} day${loopStreak === 1 ? '' : 's'}</strong>
                            </div>
                            <div class="loop-history">
                                 History: ${historyDates || '<em style="color:#777;">None yet</em>'}
                            </div>
                        </div>
                        <div class="loop-card-actions">
                            <button
                                class="nes-btn ${isCompletedToday ? 'is-disabled' : 'is-success'}"
                                ${isCompletedToday ? 'disabled' : ''}
                                onclick="completeLoop(${loop.id}, this)">
                                ${isCompletedToday ? 'DONE!' : '✔️'}
                            </button>
                            <button class="nes-btn is-error" onclick="deleteLoop(${loop.id})">🗑️</button>
                        </div>
                    </div>
                    `;
                }).join(''); // Join all individual card HTML strings

                // Update the container's content with the generated HTML
                container.innerHTML = cardsHTML;
            }

            // Check if mobile orientation alert should be shown
            checkOrientation();
        }

        // --- Core Actions ---

        function addLoop() {
            const input = document.getElementById('loopInput');
            const typeSelect = document.getElementById('loopType');
            const name = input.value.trim();
            const type = typeSelect.value;

            // Basic validation: ensure name is not empty
            if (!name) {
                alert('Please enter a name for your loop!');
                input.focus();
                return;
            }

            // Create the new loop object
            const newLoop = {
                id: Date.now() + Math.random(), // Simple unique ID
                name: name,
                type: type,
                created: getIndianTime().toISOString(), // Store creation timestamp
                completions: [] // Initialize completions array
            };

            // Add the new loop to the state
            state.loops.push(newLoop);

            // Play appropriate sound and effect
            if (type === 'positive') {
                playSound('add');
                confetti({ particleCount: 80, spread: 60, origin: { y: 0.6 } });
            } else {
                playSound('negative'); // Maybe a different sound for adding negative?
            }

            // Clear the input field
            input.value = '';

            // Update the UI to reflect the change, then save the new state
            updateUI();
            saveState();

            // Optional: Scroll to the bottom to show the new card
            // window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
        }

        function completeLoop(id, buttonElement) { // Keep buttonElement if needed for immediate visual feedback (though re-render handles it)
            const loop = state.loops.find(l => l.id === id);
            if (!loop) {
                console.error(`Loop with id ${id} not found.`);
                return;
            }

            const today = getTodayDateString();

            // Only proceed if the loop hasn't been completed today already
            if (!loop.completions.includes(today)) {
                loop.completions.push(today);
                updateDailyPoints(today, loop.type); // Update daily and total points

                // Play sound and effect based on loop type
                playSound(loop.type);
                if (loop.type === 'positive') {
                    confetti({ particleCount: 80, spread: 60, origin: { y: 0.6 } });
                }

                // Update UI (which will re-render the button state), then save
                updateUI();
                saveState();
            }
        }

        // Updates daily points based on completions for a given date
        function updateDailyPoints(date, typeCompleted) {
            let dailyEntry = state.dailyLog.find(entry => entry.date === date);

            // Create a new log entry for the date if it doesn't exist
            if (!dailyEntry) {
                dailyEntry = { date: date, positive: 0, negative: 0, points: 0 };
                state.dailyLog.push(dailyEntry);
                // Keep the log sorted by date (important for streak calculation)
                state.dailyLog.sort((a, b) => a.date.localeCompare(b.date));
            }

            // Increment the count for the type of loop completed
            if (typeCompleted === 'positive') {
                dailyEntry.positive++;
            } else if (typeCompleted === 'negative') {
                dailyEntry.negative++;
            }

            // Recalculate points for the day (0-10 scale based on positive ratio)
            const totalCompletionsToday = dailyEntry.positive + dailyEntry.negative;
            dailyEntry.points = totalCompletionsToday > 0
                ? Math.min(Math.max(0, Math.round((dailyEntry.positive / totalCompletionsToday) * 10)), 10)
                : 0; // Points are 0 if no completions

            // Recalculate the overall total points
            state.totalPoints = state.dailyLog.reduce((sum, day) => sum + day.points, 0);
        }

        function deleteLoop(id) {
            // Confirmation dialog before deleting
            if (!confirm('Are you sure you want to delete this loop and its history? This cannot be undone.')) {
                return;
            }

            // Filter out the loop with the matching ID
            state.loops = state.loops.filter(l => l.id !== id);

            playSound('delete'); // Play deletion sound

            // Update UI to remove the card, then save the state
            updateUI();
            saveState();
        }

        // --- Streak Calculation ---

        // Calculates and updates the overall 'state.streak' and 'state.lastUpdatedDate'
        function updateStreak(today) {
            // Find the date of the most recent log entry
            const lastLoggedDateStr = state.dailyLog.length > 0 ? state.dailyLog[state.dailyLog.length - 1].date : null;

            // If there are no logs ever, streak is 0
            if (!lastLoggedDateStr) {
                state.streak = 0;
                state.lastUpdatedDate = null;
                return;
            }

            // Use UTC dates for reliable day difference calculation
            const lastLogDate = new Date(Date.UTC(...lastLoggedDateStr.split('-').map((n, i) => i === 1 ? n - 1 : n)));
            const todayDate = new Date(Date.UTC(...today.split('-').map((n, i) => i === 1 ? n - 1 : n)));
            const diffTime = todayDate - lastLogDate;
            // Calculate difference in days (rounding handles potential DST shifts)
            const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));

            if (diffDays === 0) {
                // Logged today. Check if the streak continues from yesterday.
                if (state.lastUpdatedDate) {
                    const lastUpdate = new Date(Date.UTC(...state.lastUpdatedDate.split('-').map((n, i) => i === 1 ? n - 1 : n)));
                    const diffSinceUpdate = Math.round((todayDate - lastUpdate) / (1000 * 60 * 60 * 24));

                    if (diffSinceUpdate === 1) {
                        state.streak++; // Increment if last update was yesterday
                    } else if (diffSinceUpdate > 1) {
                        state.streak = 1; // Reset to 1 if gap since last update
                    }
                    // If diffSinceUpdate is 0, streak remains unchanged (already processed today)
                } else {
                    state.streak = 1; // First log entry is today
                }
                // Mark today as the last date processed for streak purposes
                state.lastUpdatedDate = today;

            } else if (diffDays === 1) {
                // Last log was yesterday. Streak *might* continue, but only if it was valid up to yesterday.
                // Check if the last processed date *was* yesterday. If not, streak was already broken.
                if (!state.lastUpdatedDate || state.lastUpdatedDate !== lastLoggedDateStr) {
                    state.streak = 0;
                }
                // Don't update lastUpdatedDate yet; wait for a log today.

            } else if (diffDays > 1) {
                // Gap of more than one day since last log. Streak is broken.
                state.streak = 0;
                // lastUpdatedDate remains the date of the last actual log.
            } else {
                // Should not happen with sorted logs (diffDays < 0 means future date)
                console.warn("Log date issue or future date found:", lastLoggedDateStr);
                state.streak = 0;
                state.lastUpdatedDate = null; // Reset if data seems inconsistent
            }

            // Safety check: ensure streak is not negative
            if (state.streak < 0) state.streak = 0;
        }

        // Calculates the current streak for a *single* loop
        function calculateLoopStreak(completions, today) {
            if (!completions || completions.length === 0) return 0;

            // Sort completion dates descending (newest first)
            const sortedDates = [...completions].sort((a, b) => b.localeCompare(a));

            let currentStreak = 0;
            let expectedDateStr = today;
            // Use UTC date object for calculations
            let expectedDate = new Date(Date.UTC(...expectedDateStr.split('-').map((n, i) => i === 1 ? n - 1 : n)));

            for (let i = 0; i < sortedDates.length; i++) {
                const completionDateStr = sortedDates[i];

                // Check if the completion date matches the expected date in the sequence
                if (completionDateStr === expectedDateStr) {
                    currentStreak++;
                    // Decrement the expected date to check for the previous day
                    expectedDate.setUTCDate(expectedDate.getUTCDate() - 1);
                    expectedDateStr = expectedDate.toISOString().split('T')[0];
                } else {
                    // If the first date checked wasn't today, check if it was yesterday
                    if (i === 0) {
                        const yesterdayDate = new Date(Date.UTC(...today.split('-').map((n, i) => i === 1 ? n - 1 : n)));
                        yesterdayDate.setUTCDate(yesterdayDate.getUTCDate() - 1);
                        const yesterdayStr = yesterdayDate.toISOString().split('T')[0];

                        if (completionDateStr === yesterdayStr) {
                            // If it was yesterday, streak is 1, continue checking from day before yesterday
                            currentStreak = 1;
                            expectedDate = new Date(Date.UTC(...yesterdayStr.split('-').map((n, i) => i === 1 ? n - 1 : n)));
                            expectedDate.setUTCDate(expectedDate.getUTCDate() - 1);
                            expectedDateStr = expectedDate.toISOString().split('T')[0];
                            continue; // Continue the loop to check for older dates
                        }
                    }
                    // If the date doesn't match the expected sequence, the streak is broken
                    break;
                }
            }
            return currentStreak;
        }

        // --- Import / Export ---

        function exportCSV() {
            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "LIFE LOOPS DATA EXPORT\n";
            csvContent += `Exported At,${getIndianTime().toISOString()}\n\n`;

            // Summary Section
            csvContent += "SUMMARY\n";
            csvContent += `Total Points,${state.totalPoints}\n`;
            csvContent += `Overall Streak,${state.streak}\n`; // Consistent header
            csvContent += `Last Logged Date,${state.lastUpdatedDate || 'N/A'}\n\n`; // Consistent header

            // Active Loops Section
            csvContent += "ACTIVE LOOPS\n";
            csvContent += "ID,Type,Name,Created Date,\"Completion Dates (YYYY-MM-DD)\"\n"; // Consistent header
            state.loops.forEach(loop => {
                const completionsStr = `"${loop.completions.join(',')}"`; // Comma-separated, quoted
                const nameStr = `"${(loop.name || '').replace(/"/g, '""')}"`; // Handle quotes within name
                csvContent += `${loop.id},${loop.type},${nameStr},${loop.created || ''},${completionsStr}\n`;
            });
            csvContent += "\n";

            // Daily Log Section
            csvContent += "DAILY LOG\n"; // Consistent header
            csvContent += "Date,✅ Positive Count,❌ Negative Count,⭐ Daily Points (0-10)\n"; // Consistent header
            state.dailyLog.forEach(day => {
                csvContent += `${day.date},${day.positive},${day.negative},${day.points}\n`;
            });

            // Create download link
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `life_loops_backup_${getTodayDateString()}.csv`);
            document.body.appendChild(link);
            link.click(); // Trigger download
            document.body.removeChild(link); // Clean up link element

            playSound('achievement'); // Play success sound
        }

        function importCSV(event) {
            const file = event.target.files[0];
            if (!file) return; // No file selected

            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const csvData = e.target.result;
                    const lines = csvData.split('\n').map(line => line.trim()).filter(line => line); // Split lines, trim whitespace, remove empty lines

                    // Initialize a new state object to populate from CSV
                    const newState = {
                        loops: [],
                        dailyLog: [],
                        totalPoints: 0,
                        streak: 0,
                        lastUpdatedDate: null
                    };
                    let currentSection = '';
                    let headers = []; // Used to potentially handle different column orders (though not fully implemented here)

                    // Process each line of the CSV
                    for (const line of lines) {
                        // Skip header/metadata lines
                        if (line.startsWith('LIFE LOOPS DATA EXPORT') || line.startsWith('Exported At')) continue;

                        // Identify current section
                        if (line.startsWith('SUMMARY')) { currentSection = 'summary'; continue; }
                        if (line.startsWith('ACTIVE LOOPS')) { currentSection = 'loops'; headers = []; continue; }
                        if (line.startsWith('DAILY LOG')) { currentSection = 'daily'; headers = []; continue; }

                        // Parse the CSV line into values
                        const values = parseCsvLine(line);

                        // Populate newState based on the current section
                        switch (currentSection) {
                            case 'summary':
                                // Currently, only 'Total Points' might be useful, but we recalculate it anyway.
                                // Streak and Last Logged Date are ignored here and recalculated later.
                                break;
                            case 'loops':
                                // Basic check for header row
                                if (headers.length === 0 && values[0]?.toLowerCase() === 'id') {
                                    headers = values.map(h => h.toLowerCase());
                                    continue;
                                }
                                // Ensure minimum expected columns are present
                                if (values.length >= 4) {
                                    // Parse completions, ensure valid date format
                                    const completions = values[4] ? values[4].split(',').map(d => d.trim()).filter(d => d && /^\d{4}-\d{2}-\d{2}$/.test(d)) : [];
                                    newState.loops.push({
                                        id: parseFloat(values[0]) || Date.now() + Math.random(), // Use parseFloat, provide fallback ID
                                        type: values[1]?.toLowerCase() === 'negative' ? 'negative' : 'positive', // Default to positive if invalid
                                        name: values[2] || 'Unnamed Loop',
                                        created: values[3] || new Date().toISOString(), // Provide fallback creation date
                                        completions: completions.sort() // Store completions sorted
                                    });
                                }
                                break;
                            case 'daily':
                                // Basic check for header row
                                if (headers.length === 0 && values[0]?.toLowerCase() === 'date') {
                                    headers = values.map(h => h.toLowerCase());
                                    continue;
                                }
                                // Ensure minimum columns and valid date format
                                if (values.length >= 4 && /^\d{4}-\d{2}-\d{2}$/.test(values[0])) {
                                    newState.dailyLog.push({
                                        date: values[0],
                                        positive: parseInt(values[1]) || 0,
                                        negative: parseInt(values[2]) || 0,
                                        points: parseInt(values[3]) || 0
                                    });
                                }
                                break;
                        }
                    }

                    // Replace current state with the imported state
                    state = newState;

                    // --- Post-Import Processing ---
                    // Sort daily logs (crucial for streak calculation)
                    state.dailyLog.sort((a, b) => a.date.localeCompare(b.date));
                    // Recalculate total points from the imported logs
                    state.totalPoints = state.dailyLog.reduce((sum, day) => sum + day.points, 0);
                    // Reset streak data before recalculation
                    state.lastUpdatedDate = null;
                    state.streak = 0;

                    // Update UI (this will recalculate streak), then save the fully processed state
                    updateUI();
                    saveState();

                    playSound('achievement'); // Play success sound
                    alert('Data imported successfully! 🎉');

                } catch (error) {
                    console.error("Import failed:", error);
                    alert(`Import failed: ${error.message}\nPlease ensure the CSV file format is correct.`);
                    playSound('negative'); // Play error sound
                } finally {
                    // Reset the file input to allow importing the same file again if needed
                    event.target.value = null;
                }
            };

            reader.onerror = function() {
                alert('Failed to read the selected file.');
                playSound('negative');
                event.target.value = null;
            };

            // Read the file as text
            reader.readAsText(file);
        }

        // Parses a single line of CSV, handling quoted fields and escaped quotes ("")
        function parseCsvLine(line) {
            const values = [];
            let currentVal = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    // Check for escaped quote ("")
                    if (inQuotes && line[i + 1] === '"') {
                        currentVal += '"';
                        i++; // Skip the next quote
                    } else {
                        inQuotes = !inQuotes; // Toggle quote state
                    }
                } else if (char === ',' && !inQuotes) {
                    // End of a value (if not inside quotes)
                    values.push(currentVal.trim());
                    currentVal = ''; // Reset for next value
                } else {
                    // Append character to current value
                    currentVal += char;
                }
            }
            values.push(currentVal.trim()); // Add the last value
            return values;
        }


        // --- Mobile Specific ---

        // Simple check for mobile user agents
        function isMobile() {
            // Standard mobile check regex
            return /Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        // Show/hide mobile orientation alert based on device type and orientation
        function checkOrientation() {
            const alert = document.querySelector('.mobile-alert');
            if (!alert) return; // Exit if alert element doesn't exist

            const isPortrait = window.innerHeight > window.innerWidth;

            // Show only if mobile, in portrait, and alert hasn't been dismissed
            if (isMobile() && isPortrait) {
                if (localStorage.getItem('landscapeAlertDismissed') !== 'true') {
                    alert.style.display = 'block';
                }
            } else {
                // Hide in landscape or on non-mobile devices
                alert.style.display = 'none';
            }
        }

        // Hides the alert and sets a flag in localStorage so it doesn't reappear
        function dismissAlert() {
            const alert = document.querySelector('.mobile-alert');
            if (alert) {
                alert.style.display = 'none';
            }
            // Remember dismissal preference
            localStorage.setItem('landscapeAlertDismissed', 'true');
        }

        // --- Initialization ---

        // Runs when the page content is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Perform the initial UI rendering based on loaded state
            updateUI();

            // Set up listeners for screen resize and orientation changes
            window.addEventListener('resize', checkOrientation);
            // Use orientationchange event if available (more reliable on some devices)
            if ('onorientationchange' in window) {
                window.addEventListener('orientationchange', checkOrientation);
            }

            // Check initial orientation to show/hide the alert
            checkOrientation();
        });
    </script>

</body>
</html>
